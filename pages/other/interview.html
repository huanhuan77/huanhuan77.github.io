<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTML 面试题 | 前端记录</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/logo.jpg">
    <meta name="description" content="huanhuan的前端记录">
    
    <link rel="preload" href="/assets/css/0.styles.87f88955.css" as="style"><link rel="preload" href="/assets/js/app.9a6c5131.js" as="script"><link rel="preload" href="/assets/js/2.04a1a3ae.js" as="script"><link rel="preload" href="/assets/js/74.e1a57511.js" as="script"><link rel="prefetch" href="/assets/js/10.f17decca.js"><link rel="prefetch" href="/assets/js/100.b3f0567a.js"><link rel="prefetch" href="/assets/js/101.043809e3.js"><link rel="prefetch" href="/assets/js/102.cf10d387.js"><link rel="prefetch" href="/assets/js/103.bf57b086.js"><link rel="prefetch" href="/assets/js/104.8e1e7c5b.js"><link rel="prefetch" href="/assets/js/105.eec4dde8.js"><link rel="prefetch" href="/assets/js/11.dab1ff35.js"><link rel="prefetch" href="/assets/js/12.5bf6cfd6.js"><link rel="prefetch" href="/assets/js/13.23f9a794.js"><link rel="prefetch" href="/assets/js/14.c37efbb5.js"><link rel="prefetch" href="/assets/js/15.d793ecb9.js"><link rel="prefetch" href="/assets/js/16.16384db9.js"><link rel="prefetch" href="/assets/js/17.423dd36f.js"><link rel="prefetch" href="/assets/js/18.dc2beaef.js"><link rel="prefetch" href="/assets/js/19.8958f44b.js"><link rel="prefetch" href="/assets/js/20.cd8487f5.js"><link rel="prefetch" href="/assets/js/21.6ad8ce2b.js"><link rel="prefetch" href="/assets/js/22.1badb4ff.js"><link rel="prefetch" href="/assets/js/23.bde2098e.js"><link rel="prefetch" href="/assets/js/24.bbe2b207.js"><link rel="prefetch" href="/assets/js/25.18a12911.js"><link rel="prefetch" href="/assets/js/26.e3ac03ef.js"><link rel="prefetch" href="/assets/js/27.7126f688.js"><link rel="prefetch" href="/assets/js/28.86ae001e.js"><link rel="prefetch" href="/assets/js/29.466f2690.js"><link rel="prefetch" href="/assets/js/3.7e15bc96.js"><link rel="prefetch" href="/assets/js/30.5351f319.js"><link rel="prefetch" href="/assets/js/31.50dc3983.js"><link rel="prefetch" href="/assets/js/32.29584bb7.js"><link rel="prefetch" href="/assets/js/33.1bcab5cf.js"><link rel="prefetch" href="/assets/js/34.eed55ccf.js"><link rel="prefetch" href="/assets/js/35.7fbdbc45.js"><link rel="prefetch" href="/assets/js/36.c23a2f73.js"><link rel="prefetch" href="/assets/js/37.1b911de0.js"><link rel="prefetch" href="/assets/js/38.d6d979ff.js"><link rel="prefetch" href="/assets/js/39.40e37a6c.js"><link rel="prefetch" href="/assets/js/4.50b21244.js"><link rel="prefetch" href="/assets/js/40.685a9df3.js"><link rel="prefetch" href="/assets/js/41.849255ac.js"><link rel="prefetch" href="/assets/js/42.0517ce84.js"><link rel="prefetch" href="/assets/js/43.a1956091.js"><link rel="prefetch" href="/assets/js/44.3afd0ad8.js"><link rel="prefetch" href="/assets/js/45.f983e4df.js"><link rel="prefetch" href="/assets/js/46.fa3fd507.js"><link rel="prefetch" href="/assets/js/47.43181ace.js"><link rel="prefetch" href="/assets/js/48.d0642313.js"><link rel="prefetch" href="/assets/js/49.310a22d7.js"><link rel="prefetch" href="/assets/js/5.2333cdcf.js"><link rel="prefetch" href="/assets/js/50.c9f65e83.js"><link rel="prefetch" href="/assets/js/51.0523b72e.js"><link rel="prefetch" href="/assets/js/52.6609d8b8.js"><link rel="prefetch" href="/assets/js/53.8d882bd5.js"><link rel="prefetch" href="/assets/js/54.71e9f336.js"><link rel="prefetch" href="/assets/js/55.0c986dad.js"><link rel="prefetch" href="/assets/js/56.1e4f14b2.js"><link rel="prefetch" href="/assets/js/57.711c86b0.js"><link rel="prefetch" href="/assets/js/58.c98b1d6d.js"><link rel="prefetch" href="/assets/js/59.cdc63a6e.js"><link rel="prefetch" href="/assets/js/6.45e65a2c.js"><link rel="prefetch" href="/assets/js/60.4dc0b9de.js"><link rel="prefetch" href="/assets/js/61.6f905c24.js"><link rel="prefetch" href="/assets/js/62.ccec6984.js"><link rel="prefetch" href="/assets/js/63.0b00d73e.js"><link rel="prefetch" href="/assets/js/64.64cfe667.js"><link rel="prefetch" href="/assets/js/65.19e25829.js"><link rel="prefetch" href="/assets/js/66.92cac451.js"><link rel="prefetch" href="/assets/js/67.4bb749ab.js"><link rel="prefetch" href="/assets/js/68.8669899f.js"><link rel="prefetch" href="/assets/js/69.6cc80c43.js"><link rel="prefetch" href="/assets/js/7.4a1d1358.js"><link rel="prefetch" href="/assets/js/70.e43d2565.js"><link rel="prefetch" href="/assets/js/71.30adcc29.js"><link rel="prefetch" href="/assets/js/72.90ebd374.js"><link rel="prefetch" href="/assets/js/73.c9868047.js"><link rel="prefetch" href="/assets/js/75.77a929cf.js"><link rel="prefetch" href="/assets/js/76.45f1de8a.js"><link rel="prefetch" href="/assets/js/77.7b751f62.js"><link rel="prefetch" href="/assets/js/78.3560fc0f.js"><link rel="prefetch" href="/assets/js/79.9514e372.js"><link rel="prefetch" href="/assets/js/8.032fbf97.js"><link rel="prefetch" href="/assets/js/80.f4d9e736.js"><link rel="prefetch" href="/assets/js/81.c345bbbd.js"><link rel="prefetch" href="/assets/js/82.433d47ba.js"><link rel="prefetch" href="/assets/js/83.0b41c717.js"><link rel="prefetch" href="/assets/js/84.3317eda9.js"><link rel="prefetch" href="/assets/js/85.80502423.js"><link rel="prefetch" href="/assets/js/86.02fd545f.js"><link rel="prefetch" href="/assets/js/87.0bbf1060.js"><link rel="prefetch" href="/assets/js/88.72f5cfbd.js"><link rel="prefetch" href="/assets/js/89.346b771d.js"><link rel="prefetch" href="/assets/js/9.043f5f45.js"><link rel="prefetch" href="/assets/js/90.4345db63.js"><link rel="prefetch" href="/assets/js/91.c2e52424.js"><link rel="prefetch" href="/assets/js/92.e47ebd58.js"><link rel="prefetch" href="/assets/js/93.1a6f8cc9.js"><link rel="prefetch" href="/assets/js/94.6e20617e.js"><link rel="prefetch" href="/assets/js/95.64bdbda7.js"><link rel="prefetch" href="/assets/js/96.76f39199.js"><link rel="prefetch" href="/assets/js/97.caa4c6ce.js"><link rel="prefetch" href="/assets/js/98.b9bfc221.js"><link rel="prefetch" href="/assets/js/99.8ceb9076.js">
    <link rel="stylesheet" href="/assets/css/0.styles.87f88955.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="前端记录" class="logo"> <span class="site-name can-hide">前端记录</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/link/link1.html" class="nav-link">
  链接
</a></li><li class="dropdown-item"><!----> <a href="/pages/link/link2.html" class="nav-link">
  组件库/插件
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/huanhuan77/huanhuan77.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/link/link1.html" class="nav-link">
  链接
</a></li><li class="dropdown-item"><!----> <a href="/pages/link/link2.html" class="nav-link">
  组件库/插件
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/huanhuan77/huanhuan77.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue2.0</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Jquery</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>element-ui</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vant</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>兼容性</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>图表</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>地图</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>代码块</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>资源</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>其他</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/other/util.html" class="sidebar-link">常用工具函数</a></li><li><a href="/pages/other/interview.html" aria-current="page" class="active sidebar-link">面试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_1-seo-优化" class="sidebar-link">1. SEO 优化</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_2-什么是-web-语义化-有什么好处" class="sidebar-link">2.什么是 web 语义化,有什么好处</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_3-如何进行网站优化" class="sidebar-link">3. 如何进行网站优化</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_4-常见的兼容性问题" class="sidebar-link">4.常见的兼容性问题</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_1-css-选择器及其优先级" class="sidebar-link">1. Css 选择器及其优先级</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_2-引入样式-link-和-import-的区别" class="sidebar-link">2. 引入样式 link 和 import 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_3-常见的-css-布局单位" class="sidebar-link">3. 常见的 css 布局单位</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_4-flex-布局" class="sidebar-link">4. flex 布局</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_5-盒子模型" class="sidebar-link">5. 盒子模型</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_6-元素水平垂直居中" class="sidebar-link">6. 元素水平垂直居中</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_7-隐藏元素的方法有哪些" class="sidebar-link">7. 隐藏元素的方法有哪些</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_8-visibility-和-display-的区别" class="sidebar-link">8. Visibility 和 display 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_9-浮动" class="sidebar-link">9. 浮动</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_10-bfc" class="sidebar-link">10.BFC</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_11-margin-重叠" class="sidebar-link">11. margin 重叠</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_12-两栏式布局" class="sidebar-link">12. 两栏式布局</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_13-三栏式布局" class="sidebar-link">13. 三栏式布局</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_14-定位方式" class="sidebar-link">14.定位方式</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_1-js-基本数据类型" class="sidebar-link">1.js 基本数据类型</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_2-typeof-操作符返回值" class="sidebar-link">2. typeof 操作符返回值</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_3-var-let-const-的区别" class="sidebar-link">3.Var, let ,const 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_4-作用域和作用域链" class="sidebar-link">4.作用域和作用域链</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_5-事件委托" class="sidebar-link">5.事件委托</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_6-事件传播" class="sidebar-link">6.事件传播</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_7-事件捕获" class="sidebar-link">7.事件捕获</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_8-事件冒泡" class="sidebar-link">8.事件冒泡</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_9-array-方法" class="sidebar-link">9. Array 方法</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_10-闭包" class="sidebar-link">10.闭包</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_11-从输入-url-地址到页面相应都发生了什么" class="sidebar-link">11.从输入 url 地址到页面相应都发生了什么?</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_12-session、cookie、localstorage-的区别" class="sidebar-link">12. session、cookie、localStorage 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_13-常见异步任务" class="sidebar-link">13. 常见异步任务</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_14-this-指向" class="sidebar-link">14.this 指向</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_15-http-协议" class="sidebar-link">15. http 协议</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_16-跨域" class="sidebar-link">16. 跨域</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_17-http-和-https-的区别" class="sidebar-link">17. http 和 https 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_18-get-请求和-post-请求" class="sidebar-link">18. Get 请求和 post 请求</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_19-ajax-状态码" class="sidebar-link">19.ajax 状态码</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_20-图片压缩" class="sidebar-link">20.图片压缩</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_21-原型与原型链" class="sidebar-link">21. 原型与原型链</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_22-深拷贝和浅拷贝" class="sidebar-link">22. 深拷贝和浅拷贝</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_23-和-区别是什么" class="sidebar-link">23. == 和===区别是什么？</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_24-call-bind-apply-的区别" class="sidebar-link">24.call bind apply 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_25-定义函数" class="sidebar-link">25. 定义函数</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_26-null-与-undefined-的区别" class="sidebar-link">26. null 与 undefined 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_27-同步和异步的区别" class="sidebar-link">27.同步和异步的区别</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_28-如何判断是否是数组" class="sidebar-link">28. 如何判断是否是数组？</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_29-new-一个对象的过程中发生了什么" class="sidebar-link">29. new 一个对象的过程中发生了什么</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_30-js-延迟加载的方式" class="sidebar-link">30. js 延迟加载的方式</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_31-防抖与节流" class="sidebar-link">31. 防抖与节流</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_32-内存泄漏" class="sidebar-link">32. 内存泄漏</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_33-垃圾回收机制" class="sidebar-link">33.垃圾回收机制</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_34-数组去重" class="sidebar-link">34.数组去重</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_35-前端安全问题" class="sidebar-link">35.前端安全问题</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_36-js-对象的几种创建方式" class="sidebar-link">36.js 对象的几种创建方式</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_37-高并发" class="sidebar-link">37.高并发</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_38-宏任务和微任务分别有哪些" class="sidebar-link">38.宏任务和微任务分别有哪些</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_1-es6-新特性" class="sidebar-link">1.ES6 新特性</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_3-几种模块规范" class="sidebar-link">3. 几种模块规范</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_4-箭头函数和普通函数的区别" class="sidebar-link">4.箭头函数和普通函数的区别</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_5-promise" class="sidebar-link">5.promise</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_6-继承的-6-种方法" class="sidebar-link">6.继承的 6 种方法</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_1-spa-单页面" class="sidebar-link">1. spa 单页面</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_2-vue-组件中-data-为什么必须是一个函数" class="sidebar-link">2. Vue 组件中,data 为什么必须是一个函数?</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_3-computed-和-watch-的区别" class="sidebar-link">3. Computed 和 watch 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_4-v-model-中的实现原理" class="sidebar-link">4. V-model 中的实现原理</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_5-vue-的双向绑定数据的原理" class="sidebar-link">5. Vue 的双向绑定数据的原理</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_6-生命周期" class="sidebar-link">6.生命周期</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_7-v-show-和-v-if-的区别" class="sidebar-link">7. v-show 和 v-if 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_8-v-for-和-v-if-为什么不能连用" class="sidebar-link">8. v-for 和 v-if 为什么不能连用?</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_9-vue-修饰符" class="sidebar-link">9.vue 修饰符</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_10-key-的作用是什么" class="sidebar-link">10.key 的作用是什么</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_11-keep-alive" class="sidebar-link">11.keep-alive</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_12-vue-事件绑定原理" class="sidebar-link">12.vue 事件绑定原理</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_13-vue-中是如何检测数组变化的呢" class="sidebar-link">13. vue 中是如何检测数组变化的呢</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_14-nexttick" class="sidebar-link">14. $nextTick</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/other/interview.html#使用场景" class="sidebar-link">使用场景</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#实现原理" class="sidebar-link">实现原理</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#作用" class="sidebar-link">作用：</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_15-组件通信" class="sidebar-link">15. 组件通信</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_16-vue-的单向数据流" class="sidebar-link">16.Vue 的单向数据流</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_17-vuex" class="sidebar-link">17. Vuex</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_18-vue-路由-hash-模式和-history-模式实现原理分别是什么-他们的区别是什么" class="sidebar-link">18.vue 路由 hash 模式和 history 模式实现原理分别是什么，他们的区别是什么？</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_19-route和-router-的区别" class="sidebar-link">19. $route和$router 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_20-动态路由" class="sidebar-link">20.动态路由</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_21-路由守卫" class="sidebar-link">21.路由守卫</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_22-mvvm" class="sidebar-link">22. MVVM</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_23-diff-算法" class="sidebar-link">23. diff 算法</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_24-ssr" class="sidebar-link">24. SSR</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_25-为什么不建议用-index-作为-key" class="sidebar-link">25. 为什么不建议用 index 作为 key?</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_26-你的接口请求一般放在哪个生命周期中" class="sidebar-link">26. 你的接口请求一般放在哪个生命周期中</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_27-自定义指令" class="sidebar-link">27. 自定义指令</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_28-封装-axios" class="sidebar-link">28. 封装 axios</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_29-什么是-mixin" class="sidebar-link">29.什么是 mixin ？</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_30-vue-指令" class="sidebar-link">30. vue 指令</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_31-虚拟-dom" class="sidebar-link">31.虚拟 DOM</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_32-性能优化" class="sidebar-link">32. 性能优化</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_33-vue-的优点和缺点" class="sidebar-link">33.vue 的优点和缺点</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_2-小程序的-wxss-和-css-有哪些不一样的地方" class="sidebar-link">2. 小程序的 wxss 和 css 有哪些不一样的地方？</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_3-微信小程序怎样获取用户信息" class="sidebar-link">3. 微信小程序怎样获取用户信息</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_4-微信小程序与-vue-区别" class="sidebar-link">4. 微信小程序与 vue 区别</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_5-登录流程" class="sidebar-link">5. 登录流程</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_6-生命周期-2" class="sidebar-link">6.生命周期</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_7-跳转页面" class="sidebar-link">7.跳转页面</a></li><li class="sidebar-sub-header"><a href="/pages/other/interview.html#_8-下拉刷新" class="sidebar-link">8.下拉刷新</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="html-面试题"><a href="#html-面试题" class="header-anchor">#</a> HTML 面试题</h1> <h2 id="_1-seo-优化"><a href="#_1-seo-优化" class="header-anchor">#</a> 1. SEO 优化</h2> <ul><li>创建唯一且准确的网页标题 title</li> <li>使用 <meta> 元标签</li> <li>使用语义化元素</li> <li>利用 img 中的 alt 属性</li> <li>设置 rel='nofollow' 忽略跟踪</li> <li>扁平化网站结构</li> <li>合理安排重要内容的位置</li></ul> <h2 id="_2-什么是-web-语义化-有什么好处"><a href="#_2-什么是-web-语义化-有什么好处" class="header-anchor">#</a> 2.什么是 web 语义化,有什么好处</h2> <p>Web 语义化是指通过 HTML 标记表示页面包含的信息,包含了 HTML 标签的语义化和 css 命名的语义化.</p> <ul><li><p>HTML 语义化是指:通过包含语义的标签,恰当的表示文档结构.</p></li> <li><p>css 语义化是指:为 HTML 标签添加有意义的 class,id 补充未表达的语义</p></li></ul> <p><strong>好处:</strong></p> <ul><li><p>去掉样式后页面程序清晰的结构</p></li> <li><p>搜索引擎更好地理解页面,有利于收录</p></li> <li><p>便团队项目的可持续运作及维护</p></li></ul> <h2 id="_3-如何进行网站优化"><a href="#_3-如何进行网站优化" class="header-anchor">#</a> 3. 如何进行网站优化</h2> <ul><li><p>减少 HTTP 请求数</p></li> <li><p>从设计实现层面简化页面</p></li> <li><p>合理设置 HTTP 缓存</p></li> <li><p>资源合并与压缩</p></li> <li><p>合并 CSS 图片，减少请求数的又一个好办法。</p></li> <li><p>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）</p></li> <li><p>多图片网页使用图片懒加载。</p></li> <li><p>在 js 中尽量减少闭包的使用</p></li> <li><p>尽量合并 css 和 js 文件</p></li> <li><p>尽量使用字体图标或者 SVG 图标，来代替传统的 PNG 等格式的图片</p></li> <li><p>减少对 DOM 的操作</p></li> <li><p>在 JS 中避免“嵌套循环”和 “死循环”</p></li> <li><p>尽可能使用事件委托（事件代理）来处理事件绑定的操作</p></li></ul> <h2 id="_4-常见的兼容性问题"><a href="#_4-常见的兼容性问题" class="header-anchor">#</a> 4.常见的兼容性问题</h2> <ol><li><p>png24 位的图片在 ie6 浏览器上出现背景</p> <ul><li>做成 png8，也可以引用一段脚本处理</li></ul></li> <li><p>浏览器默认的 margin 和 padding 不同</p> <ul><li>添加一个全局的 margin:0；padding：0 来统一</li></ul></li> <li><p>IE6 双边距 bug：在 IE6 下，如果对元素设置了浮动，同时又设置了 margin-left 或 margin-right，margin 值会加倍。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>#box{ float:left; width:10px; margin:0 0 0 10px;}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <h1 id="css-面试题"><a href="#css-面试题" class="header-anchor">#</a> css 面试题</h1> <h2 id="_1-css-选择器及其优先级"><a href="#_1-css-选择器及其优先级" class="header-anchor">#</a> 1. Css 选择器及其优先级</h2> <p>id 选择器,类选择器,属性选择器,伪类选择器,标签选择器,伪元素选择器,相邻兄弟选择器,子选择器,后代选择器,通配符</p> <p>优先级:!important &gt; 行内样式&gt;ID 选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符</p> <h2 id="_2-引入样式-link-和-import-的区别"><a href="#_2-引入样式-link-和-import-的区别" class="header-anchor">#</a> 2. 引入样式 link 和 import 的区别</h2> <ul><li><p>link 是 XHTML 标签,而@important 是 css 提供的</p></li> <li><p>页面被加载时,link 会同时被加载,而@important 引用的 css 会等到页面被加载完再加载</p></li> <li><p>Important 只在 IE5 以上才能识别,而 link 是 XHML 标签,无兼容问题</p></li> <li><p>Link 方式的样式权重高于 important 的权重</p></li> <li><p>Link 支持使用 js 控制 DOM 去改变样式,而 important 不支持</p></li></ul> <h2 id="_3-常见的-css-布局单位"><a href="#_3-常见的-css-布局单位" class="header-anchor">#</a> 3. 常见的 css 布局单位</h2> <ul><li><p>Px:绝对单位,页面按精确像素展示</p></li> <li><p>Em:相对单位,基准点为父节点字体的大小,如果自身定义了 font-size 则按自身来计算</p></li> <li><p>Rem:相对于根元素 html font-size 计算值的倍数只相对于根元素的大小</p></li> <li><p>Vw/vh
​ Vw:相对于视窗的宽度,视窗宽度是 100vw</p> <p>​ Vh:相对于视窗的高度,视窗高度是 100vh</p> <p><strong>区别</strong></p> <ul><li><p>Px 是固定的像素,一旦设置了就无法因为适应页面大小而改变</p></li> <li><p>Em 和 rem 是相对长度单位,长度是不固定的,更适用于响应式</p></li> <li><p>Em 是相对于其父元素来设置字体大小的,rem 是相对于根元素.</p> <p><strong>使用场景</strong></p> <ul><li><p>对于只需要适配少部分手机设备,且分辨率对页面影响不大,使用 px</p></li> <li><p>对于需要适配各种移动设备,使用 rem,例如:iphone,ipad</p></li></ul></li></ul></li></ul> <h2 id="_4-flex-布局"><a href="#_4-flex-布局" class="header-anchor">#</a> 4. flex 布局</h2> <ul><li>Flex-direction</li> <li>Flex-flow</li> <li>Flex-wrap</li> <li>Justify-content</li> <li>Align-items</li> <li>Align-content</li></ul> <h2 id="_5-盒子模型"><a href="#_5-盒子模型" class="header-anchor">#</a> 5. 盒子模型</h2> <p>标准盒子:width/height=我们设置的宽高</p> <p>怪异盒子:width/height=padding+border+width/height</p> <h2 id="_6-元素水平垂直居中"><a href="#_6-元素水平垂直居中" class="header-anchor">#</a> 6. 元素水平垂直居中</h2> <ul><li>flex 布局</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>Display:flex;
Justify-content:center;
Align-items:center
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>Absolute+transform</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><p>Absolute+负 margin</p></li> <li><p>Line-height</p></li></ul> <h2 id="_7-隐藏元素的方法有哪些"><a href="#_7-隐藏元素的方法有哪些" class="header-anchor">#</a> 7. 隐藏元素的方法有哪些</h2> <ul><li><p>Display:none</p></li> <li><p>visibility:hidden</p></li> <li><p>position:absolute</p></li> <li><p>z-index:负值</p></li> <li><p>clip-path</p></li> <li><p>transform:scale(0,0)</p></li></ul> <h2 id="_8-visibility-和-display-的区别"><a href="#_8-visibility-和-display-的区别" class="header-anchor">#</a> 8. Visibility 和 display 的区别</h2> <ul><li>visibility 设置 hidden 会隐藏元素，但是其位置还存在与页面文档流中，不会被删除，所以会触发浏览器渲染引擎的重绘</li> <li>display 设置了 none 属性会隐藏元素，且其位置也不会被保留下来，所以会触发浏览器渲染引擎的回流和重绘。</li> <li>opacity 会将元素设置为透明，但是其位置也在页面文档流中，不会被删除，所以会触发浏览器渲染引擎的重绘</li></ul> <h2 id="_9-浮动"><a href="#_9-浮动" class="header-anchor">#</a> 9. 浮动</h2> <p><strong>浮动引起的问题:</strong></p> <ul><li><p>父元素的高度无法撑开,影响与父元素同级的元素</p></li> <li><p>与浮动元素同级的非浮动元素会跟随其后</p></li></ul> <p><strong>清除浮动:</strong></p> <ul><li>给父级 div 定义 height 属性</li> <li>最后一个浮动元素之后添加一个空的 div 元素,并添加 clear:both 样式</li> <li>包含浮动元素的父级标签添加 overflow:hidden 或者 overflow:auto</li> <li>使用:after 伪元素</li></ul> <h2 id="_10-bfc"><a href="#_10-bfc" class="header-anchor">#</a> 10.BFC</h2> <ul><li>BFC 称为块格式化上下文,是一个独立的布局环境,可以理解为一个容器,在这个容器中按照一定规则进行物件摆放,并不会影响其他环境中的物品</li> <li>如果一个元素符合触发 BFC 的条件,则 BFC 中的元素布局不受外部影响</li></ul> <p><strong>创建 BFC 的条件:</strong></p> <ul><li><p>根元素:body</p></li> <li><p>元素设置浮动:float 除 none 以外的值</p></li> <li><p>元素设置绝对定位:position(absolute,fixed)</p></li> <li><p>display 值为:inline-block,table-cell,table-caption,flex</p></li> <li><p>overflow 值为:hidden,auto,scroll</p></li></ul> <p><strong>BFC 的作用:</strong></p> <ul><li><p>解决 margin 的重叠问题</p></li> <li><p>解决高度塌陷问题</p></li> <li><p>创建自适应两栏布局</p></li></ul> <h2 id="_11-margin-重叠"><a href="#_11-margin-重叠" class="header-anchor">#</a> 11. margin 重叠</h2> <p>两个块级元素的上边距和下边距可能会合并为一个外边距,其大小会取其中外边距最大的那个.浮动的元素和绝对定位这种脱离文档流的元素外边距不会重叠.</p> <p><strong>计算原则:</strong></p> <ul><li>如果两者是正数,取最大者</li> <li>如果一正一负,正值减去负值的绝对值</li> <li>两个负值,用 0 减去两个中绝对值大的那个</li></ul> <p><strong>解决办法:</strong></p> <ul><li><p>兄弟之间重叠:</p> <ul><li>底部元素变为行内元素:display:inline-block</li> <li>底部元素设置浮动:float</li> <li>底部元素的 position 值为:absolute/fixed</li></ul></li> <li><p>父子之间重叠:</p></li> <li><p>父元素加入:overflow:hidden</p></li> <li><p>父元素添加透明边框:border:1px solid transparent</p></li> <li><p>子元素变为行内盒子:display:inline-block</p></li> <li><p>子元素加入浮动属性或者定位</p></li></ul> <h2 id="_12-两栏式布局"><a href="#_12-两栏式布局" class="header-anchor">#</a> 12. 两栏式布局</h2> <ul><li><p>Float</p> <ul><li>左边: float:left</li> <li>右边: margin-left wiidth:auto</li></ul></li> <li><p>flex 布局</p> <ul><li><p>左边</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>flex-shrink:0;
flex-grow:0;
flex-basis:200px
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>左边元素的放大和缩小比例设置为 0,基础大小设置为 200px</p></li> <li><p>右边 flex:auto</p></li></ul></li> <li><p>绝对定位</p> <ul><li>左边:绝对定位 宽度 200px</li> <li>右边:margin-left:200px</li></ul></li> <li><p>绝对定位</p> <ul><li><p>左边宽度 200px</p></li> <li><p>右边</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>position:absolute;
left:200px
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul></li></ul> <h2 id="_13-三栏式布局"><a href="#_13-三栏式布局" class="header-anchor">#</a> 13. 三栏式布局</h2> <ul><li><p>绝对定位:左右两栏绝对定位,中间设置对应大小的 margin 的值</p></li> <li><p>Flex 布局:</p></li> <li><p>父元素设置为弹性盒子</p></li> <li><p>左边 order:-1 将左边移到左侧</p></li> <li><p>左右两侧使用 flex-basis 设置元素本身大小</p></li> <li><p>中间使用 flex-grow:1 设置占满剩余空间</p></li></ul> <h2 id="_14-定位方式"><a href="#_14-定位方式" class="header-anchor">#</a> 14.定位方式</h2> <ul><li><p>Static:正常文档流定位</p></li> <li><p>Relative:相对定位</p></li> <li><p>Absolute:绝对定位</p></li> <li><p>Fixed:指定元素相对于屏幕的位置来指定元素位置</p></li> <li><p>Sticky:粘性定位</p></li></ul> <h1 id="js-面试题"><a href="#js-面试题" class="header-anchor">#</a> JS 面试题</h1> <h2 id="_1-js-基本数据类型"><a href="#_1-js-基本数据类型" class="header-anchor">#</a> 1.js 基本数据类型</h2> <p>String,Boolean,Number,Null,Undefined,Object,Symbol,BigInt</p> <h2 id="_2-typeof-操作符返回值"><a href="#_2-typeof-操作符返回值" class="header-anchor">#</a> 2. typeof 操作符返回值</h2> <ul><li>number</li> <li>string</li> <li>boolean</li> <li>undefined</li> <li>object</li> <li>function</li> <li>symbol</li></ul> <h2 id="_3-var-let-const-的区别"><a href="#_3-var-let-const-的区别" class="header-anchor">#</a> 3.Var, let ,const 的区别</h2> <ul><li>Var 声明的变量属于函数作用域,let 和 const 属于块级作用域</li> <li>Var 存在变量提升,而 let 和 const 没有</li> <li>Var 变量可以重复声明,值可以改变,在同一格块级作用域下,let 变量不能重复声明,const 定义的变量是常量,声明时必须赋值,且不允许重复定义,如果定义的是引用类型,可以修改数据内部结构</li></ul> <h2 id="_4-作用域和作用域链"><a href="#_4-作用域和作用域链" class="header-anchor">#</a> 4.作用域和作用域链</h2> <p><strong>作用域:</strong></p> <ul><li>全局作用域:任何不在函数中或是大括号中声明的变量,都在全局作用域下,全局作用域下声明的变量可以在任意位置访问</li> <li>函数作用域:也叫局部作用域,如果一个变量是在函数内部声明的它就在一个函数作用域下</li> <li>块级作用域:在花括号中声明的变量</li></ul> <p><strong>作用域链:</strong></p> <p>当在 js 中使用一个变量的时候,首先 js 引擎会尝试在当前作用域下去寻找该变量,如果没有找到,再到他的上层作用域寻找,以此类推直到找到该变量或者是已经到达了全局作用域</p> <h2 id="_5-事件委托"><a href="#_5-事件委托" class="header-anchor">#</a> 5.事件委托</h2> <p>利用浏览器冒泡机制.在事件冒泡过程中会上传到父节点,父节点可以通过事件对象获取到目标节点,因此把子节点的监听函数定义在父节点上,由父节点的监听函数统一处理多个子元素的事件。</p> <h2 id="_6-事件传播"><a href="#_6-事件传播" class="header-anchor">#</a> 6.事件传播</h2> <p>当事件发生在 DOM 元素上时,该事件并不完全发生在那个元素上.
三个阶段:</p> <ul><li>捕获阶段:事件从 window 开始,然后向下到每个元素,直到到达目标事件或 event.target</li> <li>目标阶段:事件以到达目标元素</li> <li>冒泡阶段:事件从目标元素冒泡,然后上升到每个元素,直到到达 window</li></ul> <p><strong>阻止事件冒泡</strong></p> <ul><li>event.stopPropagation</li></ul> <p><strong>阻止事件默认行为</strong></p> <ul><li>event.preventDefault</li></ul> <h2 id="_7-事件捕获"><a href="#_7-事件捕获" class="header-anchor">#</a> 7.事件捕获</h2> <p>在捕获阶段,事件从 window 开始,一直到触发事件的元素.window -&gt; document -&gt; html -&gt; body -&gt; 目标元素</p> <h2 id="_8-事件冒泡"><a href="#_8-事件冒泡" class="header-anchor">#</a> 8.事件冒泡</h2> <p>当前元素 -&gt; body -&gt; html -&gt; document -&gt; window</p> <h2 id="_9-array-方法"><a href="#_9-array-方法" class="header-anchor">#</a> 9. Array 方法</h2> <p><strong>改变原数组的方法</strong></p> <ul><li>splice 添加/删除数组元素 返回新数组</li> <li>sort 数组排序 返回排序后的数组</li> <li>pop() 删除一个数组中的最后的一个元素 返回被删除元素</li> <li>shift() 删除数组的第一个元素 返回被删除元素</li> <li>unshift 向数组的开头添加一个或更多元素 返回该数组的新长度</li> <li>push() 向数组的末尾添加元素 返回该数组的新长度</li> <li>reverse 颠倒数组中元素的顺序 颠倒后的新数组</li></ul> <p><strong>不改变数组的方法</strong></p> <ul><li>slice() 浅拷贝数组的元素 返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象</li> <li>join() 数组转字符串 返回生成的字符串</li> <li>concat() 合并两个或多个数组 返回合并后的新数组</li> <li>indexOf() 查找数组是否存在某个元素 返回下标</li> <li>lastIndexOf() 查找指定元素在数组中的最后一个位置 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</li> <li>includes() 查找数组是否包含某个元素 返回布尔</li></ul> <p><strong>其他方法</strong></p> <ul><li>map 创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</li> <li>filter 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素</li></ul> <h2 id="_10-闭包"><a href="#_10-闭包" class="header-anchor">#</a> 10.闭包</h2> <ol><li><p>函数里面声明函数,使得子函数可以访问父函数中所有的局部变量</p></li> <li><p>保护变量不受外界污染,使其一直在内存中</p></li></ol> <p>缺点:消耗内存</p> <h2 id="_11-从输入-url-地址到页面相应都发生了什么"><a href="#_11-从输入-url-地址到页面相应都发生了什么" class="header-anchor">#</a> 11.从输入 url 地址到页面相应都发生了什么?</h2> <ul><li>浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期。</li> <li>DNS 解析 URL 对应的 IP</li> <li>建立 TCP 连接（三次握手）。</li> <li>HTTP 发起请求</li> <li>服务器处理请求,浏览器接收 HTTP 响应</li> <li>渲染页面,构建 DOm 树</li> <li>关闭 TCP 连接(四次握手)</li></ul> <h2 id="_12-session、cookie、localstorage-的区别"><a href="#_12-session、cookie、localstorage-的区别" class="header-anchor">#</a> 12. session、cookie、localStorage 的区别</h2> <ul><li>数据存储方面：cookie 在同源的 HTTP 请求里，在服务器和客户端来回传,storage 是本地保存。</li> <li>存储数据大小：cookie 限制 4kb，storage 约 5MB。</li> <li>数据有效期：cookie 的有效期与过期时间设置有关，sessionStorage 当前标签页有效， localStorage 始终有效。</li> <li>作用域：cookie、localStorage 同源窗口，sessionStorage 当前标签页</li></ul> <h2 id="_13-常见异步任务"><a href="#_13-常见异步任务" class="header-anchor">#</a> 13. 常见异步任务</h2> <p>定时器,ajax,回调函数,async await,promise，事件绑定</p> <h2 id="_14-this-指向"><a href="#_14-this-指向" class="header-anchor">#</a> 14.this 指向</h2> <ul><li>全局环境指向 window</li> <li>全局调用函数指向 window</li> <li>对象调用函数指向对象</li> <li>箭头函数指向外部的 this</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>函数形式              fun()  -&gt;window
方法形式调用          obj.sayName()  -&gt;obj
构造函数              new Test()     -&gt;新创建的对象
Call,apply,bind       p.call(obj)    -&gt; obj
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_15-http-协议"><a href="#_15-http-协议" class="header-anchor">#</a> 15. http 协议</h2> <p>五层网络模型</p> <ul><li>物理层：主要作用是定义物理设备如何传输数据传输层</li> <li>数据链路层：在通信的实体间建立数据链路连接</li> <li>网络层：为数据在结点之间传输创建逻辑链路</li> <li>传输层：向用户提供可靠的端到端（End-to-End）服务，传输层向高层屏蔽了下层数据通信的细节</li> <li>应用层：为应用软件提供了很多服务，构建于 TCP 协议之上，屏蔽网络传输相关细节</li></ul> <h2 id="_16-跨域"><a href="#_16-跨域" class="header-anchor">#</a> 16. 跨域</h2> <p>同源策略(协议,端口,域名相同)</p> <p><strong>解决跨域</strong></p> <ul><li><p>jsonp</p></li> <li><p>iframe</p></li> <li><p>cors 服务器设置 Access-Control-Allow-Origin HTTP 响应头</p></li> <li><p>window.postMessage</p></li> <li><p>Nginx 反向代理
这种方式目前使用相当普遍，就是在目标服务器和浏览器中间架一层服务器，我们称该服务器为代理服务器。方向代理的方式就是把静态的资源文件部署在代理服务器上，那么我们请求的时候，输入的是代理服务器的域，在静态的 html 的文件被加载后，要发起的 ajax 请求本来应该是直接发到目标服务器的，但是这样一来就会跨域，从而被限制，那么我们修改一下策略，让 ajax 的请求直接请求到代理服务器，然后代理服务器转发该请求到目标服务器去拿到资源。这样一来，对于浏览器端而言，并没有发生跨域。所以关键是需要在代理服务器上部署转发请求的逻辑。</p></li> <li><p>node.js 中间件代理</p></li></ul> <h2 id="_17-http-和-https-的区别"><a href="#_17-http-和-https-的区别" class="header-anchor">#</a> 17. http 和 https 的区别</h2> <ul><li>http 的 url 由 http://起始默认使用 80 端口,https 由 https 起始且默认使用 443 端口</li> <li>http 是超文本传输协议,信息是明文传输,https 是 ssl 加密传输协议</li> <li>http 的连接是无状态的,https 是由 ssl+http 协议构建的可进行加密传输,身份认证的网络协议,比 http 安全</li></ul> <h2 id="_18-get-请求和-post-请求"><a href="#_18-get-请求和-post-请求" class="header-anchor">#</a> 18. Get 请求和 post 请求</h2> <p><strong>Get 请求:</strong></p> <ul><li>用于获取数据</li> <li>把参数拼接在 URL 后面,发送给服务器</li> <li>大小有限制</li></ul> <p><strong>Post 请求</strong></p> <ul><li>传递参数,把参数放在请求体中,发送给服务器</li> <li>对大小没有要求</li> <li>安全性高</li></ul> <h2 id="_19-ajax-状态码"><a href="#_19-ajax-状态码" class="header-anchor">#</a> 19.ajax 状态码</h2> <ul><li>200 响应成功</li> <li>401 权限不足</li> <li>400 客户端请求有语法错误，不能被服务器识别</li> <li>403 禁止访问</li> <li>404 请求资源不存在</li> <li>500 服务器内部错误</li></ul> <h2 id="_20-图片压缩"><a href="#_20-图片压缩" class="header-anchor">#</a> 20.图片压缩</h2> <p>Base64,canvas,图片懒加载</p> <h2 id="_21-原型与原型链"><a href="#_21-原型与原型链" class="header-anchor">#</a> 21. 原型与原型链</h2> <p><strong>原型</strong></p> <p>创建一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象，普通函数没有 prototype，但有—proto—属性</p> <p><strong>原型链</strong></p> <p>当对象查找一个属性的时候,如果没有在自身找到,那么就会查找自身的原型,如果原型还没有找到,那么会继续查找原型的原型,直到找到 Object.prototype 的原型时,此时原型为 null,查找停止.</p> <h2 id="_22-深拷贝和浅拷贝"><a href="#_22-深拷贝和浅拷贝" class="header-anchor">#</a> 22. 深拷贝和浅拷贝</h2> <p><strong>浅拷贝</strong></p> <p>浅拷贝是对内存地址的复制，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变</p> <ol><li><p>自定义函数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function simpleCopy(initObj){
    var obj={}
    for(var i in initObj){
    obj[i]=initObj[i]
    }
    return obj;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p>Object.assign</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let newObj=Object.assign({},obj)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>ES6 的对象扩展</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let newObj={...obj}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <p><strong>深拷贝</strong></p> <p>是指拷贝对象的具体内容，而内存地址是自主分配的，拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let newObj=JSON.parse(JSON.stringify(obj))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_23-和-区别是什么"><a href="#_23-和-区别是什么" class="header-anchor">#</a> 23. == 和===区别是什么？</h2> <ul><li>==返回一个布尔值，相等返回 true，不相等返回 false；允许不同数据类型直接的比较；如果是不同类型的数据进行比较时，会默认进行数据类型直接的转换，如果是对象数据类型的比较，比较的是空间地址</li> <li>只要数据类型不一样，就会返回 false</li></ul> <h2 id="_24-call-bind-apply-的区别"><a href="#_24-call-bind-apply-的区别" class="header-anchor">#</a> 24.call bind apply 的区别</h2> <ul><li>call 和 apply 是直接调用函数，第一个参数是改变 this 指向的对象结果值</li> <li>call 第二个参数开始，后续所有参数就是传入该函数的值，跟普通函数传参一样</li> <li>apply 第二个参数是数组，该数组就是该函数的实参</li> <li>bind 不会立即调用函数，而是返回一个改变 this 指向后的函数，然后再调用，参数跟 call 相同</li> <li>如果不想改变 this 指向了，第一个参数传入 null，指向 window</li></ul> <h2 id="_25-定义函数"><a href="#_25-定义函数" class="header-anchor">#</a> 25. 定义函数</h2> <ul><li>函数声明 function name(){}</li> <li>函数表达式 var name=function (){}</li> <li>new 实例化</li></ul> <h2 id="_26-null-与-undefined-的区别"><a href="#_26-null-与-undefined-的区别" class="header-anchor">#</a> 26. null 与 undefined 的区别</h2> <ul><li><p>null 表示一个对象被定义了，值为“空值”；</p></li> <li><p>undefined 表示不存在这个值。</p></li></ul> <h2 id="_27-同步和异步的区别"><a href="#_27-同步和异步的区别" class="header-anchor">#</a> 27.同步和异步的区别</h2> <p><strong>同步</strong></p> <ul><li>同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</li></ul> <p><strong>异步</strong></p> <ul><li>异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理</li></ul> <p><strong>异步操作</strong></p> <ul><li><p>setTimeout(setInterval)</p></li> <li><p>ajax</p></li> <li><p>promise</p></li> <li><p>async/await</p></li> <li><p>回调函数</p></li> <li><p>事件绑定</p></li></ul> <h2 id="_28-如何判断是否是数组"><a href="#_28-如何判断是否是数组" class="header-anchor">#</a> 28. 如何判断是否是数组？</h2> <ul><li><p>Array.isArray</p></li> <li><p>instanceof</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>arr instanceof Array
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>constructor</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>arr.constructor === Array
arr.__proto__.constructor === Array
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>Object.prototype.toString</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Object.prototype.toString.call(arr) === '[object Array]'
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h2 id="_29-new-一个对象的过程中发生了什么"><a href="#_29-new-一个对象的过程中发生了什么" class="header-anchor">#</a> 29. new 一个对象的过程中发生了什么</h2> <ol><li>创建空对象；
var obj = {};</li> <li>设置新对象的 constructor 属性为构造函数的名称，设置新对象的<strong>proto</strong>属性指向构造函数的 prototype 对象；
obj.<strong>proto</strong> = ClassA.prototype;</li> <li>使用新对象调用函数，函数中的 this 被指向新实例对象：
ClassA.call(obj);//{}.构造函数();</li> <li>将初始化完毕的新对象地址，保存到等号左边的变量中</li></ol> <h2 id="_30-js-延迟加载的方式"><a href="#_30-js-延迟加载的方式" class="header-anchor">#</a> 30. js 延迟加载的方式</h2> <ol><li>将 js 脚本放在文档底部，来使 js 脚本尽可能的在最后来加载执行</li> <li>给 js 脚本添加 defer 属性</li> <li>给 js 脚本添加 async 属性</li> <li>动态创建 DOM 标签的方式</li></ol> <h2 id="_31-防抖与节流"><a href="#_31-防抖与节流" class="header-anchor">#</a> 31. 防抖与节流</h2> <p><strong>防抖</strong></p> <p>在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。使用在点击请求的事件上，避免因为用户的多次点击向后端发送多次请求</p> <p><strong>节流</strong></p> <p>规定一个单位时间内，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。scroll 函数的事件监听</p> <h2 id="_32-内存泄漏"><a href="#_32-内存泄漏" class="header-anchor">#</a> 32. 内存泄漏</h2> <ol><li>意外的全局变量</li> <li>被遗忘的计时器或回调函数</li> <li>脱离 dom 的引用</li> <li>闭包</li></ol> <h2 id="_33-垃圾回收机制"><a href="#_33-垃圾回收机制" class="header-anchor">#</a> 33.垃圾回收机制</h2> <h2 id="_34-数组去重"><a href="#_34-数组去重" class="header-anchor">#</a> 34.数组去重</h2> <ul><li>indexof if (array .indexOf(arr[i]) === -1)</li> <li>new Set Array.from(new Set(arr))</li> <li>includes if( !array.includes( arr[i]) )</li> <li>sort</li></ul> <h2 id="_35-前端安全问题"><a href="#_35-前端安全问题" class="header-anchor">#</a> 35.前端安全问题</h2> <ol><li><p>XSS</p> <ul><li><p>解决方案：</p> <ul><li><p>对用户的输入进行过滤</p></li> <li><p>根据输出数据所在的上下文来进行相应的编码</p></li> <li><p>在 cookie 中设置 HttpOnly 属性，使 js 脚本无法读取到 cookie 信息</p></li></ul></li></ul></li> <li><p>csrf</p> <ul><li>解决方案
<ul><li>使用 token</li> <li>referer 验证</li> <li>使用验证码</li></ul></li></ul></li> <li><p>点击劫持</p> <ul><li>解决方案：
<ul><li>设置 http 响应头 X-Frame-Options</li> <li>使用 CSP(Content Security Policy)内容安全策略</li></ul></li></ul></li> <li><p>不安全的第三方依赖</p> <ul><li>解决方案：
<ul><li>尽量减少第三方依赖，选用相对成熟的依赖包</li> <li>使用自动化工具检查这些第三方代码有没有安全问题</li></ul></li></ul></li> <li><p>本地存储数据泄露</p> <ul><li>解决方案：
<ul><li>不在本地存储重要数据</li> <li>加密</li></ul></li></ul></li></ol> <h2 id="_36-js-对象的几种创建方式"><a href="#_36-js-对象的几种创建方式" class="header-anchor">#</a> 36.js 对象的几种创建方式</h2> <h2 id="_37-高并发"><a href="#_37-高并发" class="header-anchor">#</a> 37.高并发</h2> <ul><li>减少 http 请求，减少 css，js,image 等组件的请求数</li> <li>添加异步请求</li> <li>启用浏览器缓存和文件压缩</li> <li>cdn 加速</li> <li>建立独立的图片服务器</li></ul> <h2 id="_38-宏任务和微任务分别有哪些"><a href="#_38-宏任务和微任务分别有哪些" class="header-anchor">#</a> 38.宏任务和微任务分别有哪些</h2> <ul><li>微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</li> <li>宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等</li></ul> <h1 id="es6-面试题"><a href="#es6-面试题" class="header-anchor">#</a> ES6 面试题</h1> <h2 id="_1-es6-新特性"><a href="#_1-es6-新特性" class="header-anchor">#</a> 1.ES6 新特性</h2> <ul><li>块作用域</li> <li>类</li> <li>箭头函数</li> <li>模板字符串</li> <li>加强的对象字面</li> <li>对象解构</li> <li>Promise</li> <li>模块</li> <li>Symbol</li> <li>代理（proxy）Set</li> <li>函数默认参数</li> <li>rest 和展开</li></ul> <h2 id="_3-几种模块规范"><a href="#_3-几种模块规范" class="header-anchor">#</a> 3. 几种模块规范</h2> <p><strong>模块化</strong></p> <ul><li>将一个复杂的程序依据一定的规范封装成几个块（文件），并进行组合在一起</li> <li>块的内部数据与实现是私有的，只是向外部暴露一些方法与外部模块通信</li></ul> <p><strong>模块规范</strong></p> <ul><li>CommonJS 方案，它通过 require 来引入模块。通过 module.exports 定义模块的输出接口。这种模块加载方案是服务端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件存储在本地磁盘，所以读取非常快，所以以同步的方式加载更合适</li> <li>AMD 方案，这种方案是采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范</li> <li>CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js 区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同</li> <li>ES6 提出的 import 和 export 形式来导入导出模块</li></ul> <h2 id="_4-箭头函数和普通函数的区别"><a href="#_4-箭头函数和普通函数的区别" class="header-anchor">#</a> 4.箭头函数和普通函数的区别</h2> <ul><li>普通函数的 this 指向调用他的那个对象</li> <li>箭头函数不能作为构造函数，不能使用 new，没有 this，arguments</li> <li>箭头函数的 this 永远指向其上下文的 this，任何方法都改变不了</li></ul> <h2 id="_5-promise"><a href="#_5-promise" class="header-anchor">#</a> 5.promise</h2> <p><strong>基本特征</strong></p> <ol><li>有 3 种状态：pending（进行中）、fulfilled（已成功）、rejected（已失败）</li> <li>接收一个回调函数作为参数，回调函数接收 2 格参数，resolve 成功时的回调，reject 失败时的回调</li> <li>finally 方法不管 promise 状态如何都会执行</li></ol> <p><strong>如何改变 Promise 对象的状态</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>resolve() // pending =&gt; fulfilled
reject() // pending =&gt; rejected
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>优点</strong></p> <ol><li>统一异步 API</li> <li>解决回调地狱的问题</li> <li>更好的处理错误</li></ol> <p><strong>缺点</strong></p> <ol><li>无法取消 promise，一旦建立立即执行，中兔无法取消</li> <li>如果不设置回调函数，promise 内部跑出的错误，不会反应到外部</li> <li>当处于 pending 状态时，无法得知目前进展到哪一步</li> <li>promise 真正执行回调的时候，定义 promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好，</li></ol> <h2 id="_6-继承的-6-种方法"><a href="#_6-继承的-6-种方法" class="header-anchor">#</a> 6.继承的 6 种方法</h2> <ol><li>构造函数继承 （call,apply)</li> <li>原型继承 将子类的原型挂载到父类上</li> <li>组合继承</li> <li>寄生组合继承</li> <li>class 继承</li></ol> <h1 id="vue-面试题"><a href="#vue-面试题" class="header-anchor">#</a> vue 面试题</h1> <h2 id="_1-spa-单页面"><a href="#_1-spa-单页面" class="header-anchor">#</a> 1. spa 单页面</h2> <p><strong>优点</strong></p> <ul><li>用户体验好,内容的改变不需要重新加载整个页面</li> <li>相对服务器压力小</li> <li>前后端职责分离,架构清晰</li></ul> <p><strong>缺点:</strong></p> <ul><li>初次加载耗时多,需要在加载页面时,将 js,css 统一加载</li> <li>单页面在一个页面显示所有的内容,所以不能用浏览器的前进后退功能.</li></ul> <h2 id="_2-vue-组件中-data-为什么必须是一个函数"><a href="#_2-vue-组件中-data-为什么必须是一个函数" class="header-anchor">#</a> 2. Vue 组件中,data 为什么必须是一个函数?</h2> <p>因为组件是用来复用的,且 JS 里对象是引用关系,如果组件中 data 是一个对象,那么这样作用域没有隔离,子组件中的 data 属性值会相互影响,如果 data 选项是一个函数,那么每个实例可以维护一份被返回对象的独立拷贝,组件实例直接的 data 属性值不会相互影响,而 new Vue 的实例,是不会被复用的,因此不存在引用对象的问题.</p> <h2 id="_3-computed-和-watch-的区别"><a href="#_3-computed-和-watch-的区别" class="header-anchor">#</a> 3. Computed 和 watch 的区别</h2> <ul><li>Computed:只有当依赖的数据变化时才会计算,当数据没有变化时,它会读取缓存数据,如果一个数据依赖于其他数据,使用 computed</li> <li>Watch:每次都需要执行函数,watch 更适用于数据变化时的异步操作,如果需要在某个数据变化时做一些事情,使用 watch</li></ul> <h2 id="_4-v-model-中的实现原理"><a href="#_4-v-model-中的实现原理" class="header-anchor">#</a> 4. V-model 中的实现原理</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>Value+input的语法糖相当于
&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_5-vue-的双向绑定数据的原理"><a href="#_5-vue-的双向绑定数据的原理" class="header-anchor">#</a> 5. Vue 的双向绑定数据的原理</h2> <p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式,通过 object.defineProperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发相应的监听回调</p> <h2 id="_6-生命周期"><a href="#_6-生命周期" class="header-anchor">#</a> 6.生命周期</h2> <ul><li><p>beforeCreate:实例创建之初</p></li> <li><p>Created:实例创建完成 可以拿到 data</p></li> <li><p>beforeMount:挂载前</p></li> <li><p>mounted:实例挂载后,可以获取 dom 节点</p></li> <li><p>BeforeUpdate:响应数据更新时</p></li> <li><p>Updated:组件数据更新之后</p></li> <li><p>beforeDestory:组件销毁前</p></li> <li><p>destoryed:组件销毁后调用</p></li></ul> <h2 id="_7-v-show-和-v-if-的区别"><a href="#_7-v-show-和-v-if-的区别" class="header-anchor">#</a> 7. v-show 和 v-if 的区别</h2> <p>v-if 是删除生成 dom,v-show 是切换 dispaly 的状态，v-show 适用于频繁切换条件的场景</p> <h2 id="_8-v-for-和-v-if-为什么不能连用"><a href="#_8-v-for-和-v-if-为什么不能连用" class="header-anchor">#</a> 8. v-for 和 v-if 为什么不能连用?</h2> <p>V-for 会比 v-if 的优先级更高,连用的话会把 v-if 放入每个元素都添加一下,造成性能问题</p> <h2 id="_9-vue-修饰符"><a href="#_9-vue-修饰符" class="header-anchor">#</a> 9.vue 修饰符</h2> <ul><li><p>Stop:阻止事件冒泡</p></li> <li><p>Prevent:阻止事件的默认行为</p></li> <li><p>Capture:事件捕获由外到内</p></li> <li><p>Once:只触发一次</p></li> <li><p>Self:只触发自己的事件行为时,才会执行</p></li></ul> <h2 id="_10-key-的作用是什么"><a href="#_10-key-的作用是什么" class="header-anchor">#</a> 10.key 的作用是什么</h2> <p>使用 v-for 更新已渲染的元素列表时,默认用就地复用策略;列表数据修改的时候,他会根据 key 值去判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素</p> <h2 id="_11-keep-alive"><a href="#_11-keep-alive" class="header-anchor">#</a> 11.keep-alive</h2> <p>一般结合路由和动态组件一起使用，用于缓存组件；</p> <ul><li>Include 属性 只有名称匹配的组件会被缓存</li> <li>Exclude 属性 任何名称匹配的组件都不会被缓存</li> <li>Exclude 比 include 优先级高</li> <li>对应钩子 activated:组件被激活时 deactivated:组件移除时</li></ul> <h2 id="_12-vue-事件绑定原理"><a href="#_12-vue-事件绑定原理" class="header-anchor">#</a> 12.vue 事件绑定原理</h2> <ul><li>原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过 Vue 自定义的<code>$on</code>实现的。</li></ul> <h2 id="_13-vue-中是如何检测数组变化的呢"><a href="#_13-vue-中是如何检测数组变化的呢" class="header-anchor">#</a> 13. vue 中是如何检测数组变化的呢</h2> <ul><li>使用了函数劫持的方式，重写了数组的方法，Vue 将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法，当调用数组 api 时，可以通知依赖更新。</li> <li>如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</li></ul> <h2 id="_14-nexttick"><a href="#_14-nexttick" class="header-anchor">#</a> 14. $nextTick</h2> <h3 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h3> <p>一个子组件通过 v-if 控制隐藏显示，当修改完显示状态后，立马通过 ref 去操作子组件的方法，这个时候会报错，原因在于子组件此时可能还未渲染完成，这个时候使用 nextTick 可以解决，他会在 dom 更新完成之后再去调用。</p> <h3 id="实现原理"><a href="#实现原理" class="header-anchor">#</a> 实现原理</h3> <ul><li>在下次 DOM 更新循环结束之后执行延迟回调</li> <li>nextTick 主要使用了宏任务和微任务</li> <li>根据执行环境分别尝试采用 promise，MutationObserver，setImmediate,如果以上都不行，则采用 setTimeout 定义一个异步方法，多次调用 nextTick 会将方法放入队列中，通过这个异步方法清空当前队列</li></ul> <h3 id="作用"><a href="#作用" class="header-anchor">#</a> 作用：</h3> <p>在 Vue 生命周期的 created()钩子函数进行的 DOM 操作一定要放在 Vue.nextTick()的回调函数中。原因是什么呢，原因是在 created()钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick()的回调函数中</p> <h2 id="_15-组件通信"><a href="#_15-组件通信" class="header-anchor">#</a> 15. 组件通信</h2> <ul><li><p>Props:父组件向子组件传递数据</p></li> <li><p>$emit:子组件向父组件传值</p></li> <li><p>Ref:用在子组件上,指向子组件实例,可以访问组件的数据和方法</p></li> <li><p>$parent:访问上一级父组件的属性和方法</p></li> <li><p>$children:访问子组件的实例</p></li> <li><p>$attrs:继承所有的父组件属性</p></li> <li><p>$listeners:包含了父作用域中的事件监听器</p></li> <li><p>Provide 父组件中通过 provide 来提供变量</p></li> <li><p>Inject 然后再子组件中通过 inject 来注入变量</p></li> <li><p>EventBus：用于跨组件通知</p></li></ul> <h2 id="_16-vue-的单向数据流"><a href="#_16-vue-的单向数据流" class="header-anchor">#</a> 16.Vue 的单向数据流</h2> <p>所有的 prop 都使得其父子 prop 之间形成一个单向下行绑定,父级 prop 的更新会向下流动到子组件中,但是反过来不行,这样会防止子组件意外改变父级组件的状态,从而导致你的应用的数据流难以理解</p> <h2 id="_17-vuex"><a href="#_17-vuex" class="header-anchor">#</a> 17. Vuex</h2> <ul><li>State:定义了应用状态的数据结构,可以在这里设置默认的初始状态</li> <li>Getter:可以对 state 进行计算操作，主要用来过滤一些数据，可以在多组件之间复用</li> <li>Mutations:定义的方法动态修改 state 中的数据，通过 commit 提交方法，方法必须是同步的</li> <li>Actions：提交的是 mutation，而不是直接变更状态，可以包含任意异步操作</li> <li>Modules:类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</li></ul> <p>场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车</p> <h2 id="_18-vue-路由-hash-模式和-history-模式实现原理分别是什么-他们的区别是什么"><a href="#_18-vue-路由-hash-模式和-history-模式实现原理分别是什么-他们的区别是什么" class="header-anchor">#</a> 18.vue 路由 hash 模式和 history 模式实现原理分别是什么，他们的区别是什么？</h2> <ul><li><p>hash 模式：</p> <ul><li>即地址栏 URL 中的#符号</li> <li>hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面</li></ul></li> <li><p>history 模式：</p> <ul><li>利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法</li></ul></li> <li><p>区别</p> <ul><li>url 展示上，hash 模式有“#”，history 模式没有</li> <li>刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由</li> <li>兼容性，hash 可以支持低版本浏览器和 IE。</li></ul></li></ul> <h2 id="_19-route和-router-的区别"><a href="#_19-route和-router-的区别" class="header-anchor">#</a> 19. $route和$router 的区别</h2> <ul><li><p>$route:路由信息对象,包括 path,params,hash,query,fullPath,name 等</p></li> <li><p>$router:路由实例,包括路由跳转方法,钩子函数</p></li></ul> <h2 id="_20-动态路由"><a href="#_20-动态路由" class="header-anchor">#</a> 20.动态路由</h2> <ul><li>Params:
配置路由:/router/:id
获取:$route.params.id</li> <li>query 方式:
配置路由:/router<br>
获取参数:$route.query.id</li></ul> <h2 id="_21-路由守卫"><a href="#_21-路由守卫" class="header-anchor">#</a> 21.路由守卫</h2> <ul><li>全局前置/钩子：beforeEach、beforeResolve、afterEach
<ul><li><strong>to</strong>：route 即将进入的目标路由对象，</li> <li><strong>from</strong>：route 当前导航正要离开的路由</li> <li><strong>next</strong>：function 一定要调用该方法 resolve 这个钩子。执行效果依赖 next 方法的调用参数。可以控制网页的跳转。</li></ul></li> <li>路由独享的守卫：beforeEnter</li> <li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li></ul> <h2 id="_22-mvvm"><a href="#_22-mvvm" class="header-anchor">#</a> 22. MVVM</h2> <ul><li><p>Model 代表数据模型，View 代表 ui 组件，ViewModel 将 Model 和 View 关联起来</p></li> <li><p>数据会绑定到 ViewModel 层并自动将数据渲染到页面，视图变化的时候会通知 ViewModel 层更新数据</p></li></ul> <h2 id="_23-diff-算法"><a href="#_23-diff-算法" class="header-anchor">#</a> 23. diff 算法</h2> <ul><li>同级比较，再比较子节点</li> <li>先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)</li> <li>比较都有子节点的情况(核心 diff)</li> <li>递归比较子节点</li></ul> <h2 id="_24-ssr"><a href="#_24-ssr" class="header-anchor">#</a> 24. SSR</h2> <ul><li><p>SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端</p></li> <li><p>SSR 的优势</p> <ul><li>更好的 SEO</li> <li>首屏加载速度更快</li></ul></li> <li><p>SSR 的缺点</p> <ul><li>开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子</li> <li>当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境</li> <li>更多的服务端负载</li></ul></li></ul> <h2 id="_25-为什么不建议用-index-作为-key"><a href="#_25-为什么不建议用-index-作为-key" class="header-anchor">#</a> 25. 为什么不建议用 index 作为 key?</h2> <ul><li>不建议 用 index 作为 key，和没写基本上没区别，因为不管你数组的顺序怎么颠倒，index 都是 0, 1, 2 这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作</li></ul> <h2 id="_26-你的接口请求一般放在哪个生命周期中"><a href="#_26-你的接口请求一般放在哪个生命周期中" class="header-anchor">#</a> 26. 你的接口请求一般放在哪个生命周期中</h2> <p>在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p> <ul><li>能更快获取到服务端数据，减少页面 loading 时间；</li> <li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul> <h2 id="_27-自定义指令"><a href="#_27-自定义指令" class="header-anchor">#</a> 27. 自定义指令</h2> <ul><li>全局定义：</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.directive(&quot;focus&quot;,{})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>局部定义</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>directives:{focus:{}}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p>钩子函数：指令定义对象提供钩子函数</p> <ul><li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li> <li>inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</li> <li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。</li> <li>ComponentUpdate：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li> <li>unbind：只调用一次，指令与元素解绑时调用。</li></ul></li> <li><p>钩子参数</p> <ul><li>el：绑定元素</li> <li>bing： 指令核心对象，描述指令全部信息属性</li></ul></li></ul> <p><strong>使用场景</strong></p> <ul><li>普通 DOM 元素进行底层操作的时候，可以使用自定义指令</li> <li>自定义指令是用来操作 DOM 的。尽管 Vue 推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的 DOM 操作，并且是可复用的。</li></ul> <h2 id="_28-封装-axios"><a href="#_28-封装-axios" class="header-anchor">#</a> 28. 封装 axios</h2> <ul><li><p>options 预检请求，检测服务器是否允许跨域</p></li> <li><p>取消请求 cancelToken</p></li> <li><p>根据环境区分设置 baseURL</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if (process.env.NODE_ENV === 'development') {
  axios.defaults.baseURL = 'http://dev.xxx.com'
} else if (process.env.NODE_ENV === 'production') {
  axios.defaults.baseURL = 'http://prod.xxx.com'
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>设置超时时间和请求头信息</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>axios.defaults.timeout = 10000
// 请求头信息是为post请求设置
axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>在请求拦截器 request 判断是否存在 token，如果存在，在 http 请求的 header 加上 token</p></li> <li><p>响应拦截器</p> <ul><li>如果状态码为 200，请求成功，可以拿到数据</li> <li>否则的话就跳到相应页面或者给予提示</li> <li>在 error 对异常状态做统一处理</li></ul></li></ul> <h2 id="_29-什么是-mixin"><a href="#_29-什么是-mixin" class="header-anchor">#</a> 29.什么是 mixin ？</h2> <ul><li><p>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</p></li> <li><p>如果你希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</p></li> <li><p>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</p></li></ul> <h2 id="_30-vue-指令"><a href="#_30-vue-指令" class="header-anchor">#</a> 30. vue 指令</h2> <ul><li>v-text 更新元素的 textContent</li> <li>v-html 更新元素的 innerHTML</li> <li>v-bind 绑定一个属性</li> <li>v-on 绑定事件</li> <li>v-model 在表单元素上创建双向数据绑定</li> <li>v-for 循环</li> <li>v-if</li> <li>v-show</li></ul> <h2 id="_31-虚拟-dom"><a href="#_31-虚拟-dom" class="header-anchor">#</a> 31.虚拟 DOM</h2> <p>虚拟 Dom (Virtual DOM) 实际上它只是一层对真实 DOM 的抽象，以 JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上。在 Javascript 对象中，虚拟 DOM 表现为一个 Object 对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，</p> <h2 id="_32-性能优化"><a href="#_32-性能优化" class="header-anchor">#</a> 32. 性能优化</h2> <ul><li>不要在模板里面写过多表达式</li> <li>循环时添加 key</li> <li>按需加载,可以用 require 或者 import 按需加载需要的组件</li> <li>路由懒加载</li> <li>频繁切换使用 v-show</li></ul> <h2 id="_33-vue-的优点和缺点"><a href="#_33-vue-的优点和缺点" class="header-anchor">#</a> 33.vue 的优点和缺点</h2> <p><strong>优点</strong></p> <ul><li>轻量级的框架</li> <li>双向数据绑定</li> <li>组件化开发</li> <li>单页面路由</li> <li>学习成本低</li> <li>虚拟 dom</li> <li>渐进式框架</li> <li>数据和结构的分离</li> <li>运行速度快</li> <li>插件化</li></ul> <p><strong>缺点</strong></p> <ul><li>不支持 IE8 以下</li> <li>因为是单页面应用，不利于 seo 优化</li> <li>初次加载时耗时多</li></ul> <h1 id="小程序"><a href="#小程序" class="header-anchor">#</a> 小程序</h1> <h1 id="_1-微信小程序怎样跟事件传值"><a href="#_1-微信小程序怎样跟事件传值" class="header-anchor">#</a> 1. 微信小程序怎样跟事件传值</h1> <p>给 HTML 元素添加 data-*属性来传递我们需要的值，然后通过 e.currentTarget.dataset 或 onload 的 param 参数获取。但 data -名称不能有大写字母和不可以存放对象</p> <h2 id="_2-小程序的-wxss-和-css-有哪些不一样的地方"><a href="#_2-小程序的-wxss-和-css-有哪些不一样的地方" class="header-anchor">#</a> 2. 小程序的 wxss 和 css 有哪些不一样的地方？</h2> <ul><li><p>wxss 的图片引入需使用外链地址；</p></li> <li><p>没有 Body；样式可直接使用 import 导入</p></li></ul> <h2 id="_3-微信小程序怎样获取用户信息"><a href="#_3-微信小程序怎样获取用户信息" class="header-anchor">#</a> 3. 微信小程序怎样获取用户信息</h2> <p>微信小程序获取用户信息需要用户授权，首先用户登陆微信小程序使用 wx.login 这个 API，然后通过 wx.getUserInfo 这个 API 在拿到用户信息</p> <h2 id="_4-微信小程序与-vue-区别"><a href="#_4-微信小程序与-vue-区别" class="header-anchor">#</a> 4. 微信小程序与 vue 区别</h2> <ul><li>生命周期不一样，微信小程序生命周期比较简单</li> <li>数据绑定也不同，微信小程序数据绑定需要使用{{}}，vue 直接:就可以</li> <li>显示与隐藏元素，vue 中，使用 v-if 和 v-show 控制元素的显示和隐藏，小程序中，使用 wx-if 和 hidden 控制元素的显示和隐藏</li> <li>事件处理不同，小程序中，全用 bindtap(bind+event)，或者 catchtap(catch+event) 绑定事件,vue 使用 v-on:event 绑定事件，或者使用@event 绑定事件。</li> <li>数据双向绑定也不不一样在 vue 中,只需要再表单元素上加上 v-model,然后再绑定 data 中对应的一个值，当表单元素内容发生变化时，data 中对应的值也会相应改变，这是 vue 非常 nice 的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个 data 中声明的变量。</li></ul> <p>取值也不一样，小程序中，通过 this.data.reason 取值，vue 中，通过 this.reason 取值</p> <p>父子组件间的通信也不同</p> <h2 id="_5-登录流程"><a href="#_5-登录流程" class="header-anchor">#</a> 5. 登录流程</h2> <ul><li><p>小程序调用 wx.login 获取临时登录凭证 code,并传到开发者服务器</p></li> <li><p>开发者服务器以 code 换取用户唯一标识 openid 和会话秘钥 session-key</p></li> <li><p>临时登录凭证 code 只能使用一次</p></li></ul> <h2 id="_6-生命周期-2"><a href="#_6-生命周期-2" class="header-anchor">#</a> 6.生命周期</h2> <ul><li><p>Onload 监听页面加载</p></li> <li><p>onReady 监听页面初次渲染完成</p></li> <li><p>onShow 监听页面显示</p></li> <li><p>onHide 监听页面隐藏</p></li> <li><p>onUnload 监听页面卸载</p></li></ul> <h2 id="_7-跳转页面"><a href="#_7-跳转页面" class="header-anchor">#</a> 7.跳转页面</h2> <ul><li><p>wx.switchTab 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</p></li> <li><p>wx.reLaunch 关闭所有页面，打开到应用内的某个页面</p></li> <li><p>wx.redirectTo 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面</p></li> <li><p>wx.navigateTo 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面</p></li> <li><p>wx.navigateBack 关闭当前页面，返回上一页面或多级页面</p></li></ul> <h2 id="_8-下拉刷新"><a href="#_8-下拉刷新" class="header-anchor">#</a> 8.下拉刷新</h2> <ul><li>json 文件添加 enablePullDownRefresh&quot;: true“</li> <li>onPullDownRefresh</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">lastUpdate:</span> <span class="time">5/13/2021, 5:58:08 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/pages/other/util.html" class="prev">
        常用工具函数
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9a6c5131.js" defer></script><script src="/assets/js/2.04a1a3ae.js" defer></script><script src="/assets/js/74.e1a57511.js" defer></script>
  </body>
</html>
